# Задание 8
Основных целей две, нужно переработать код из задания про пакетную обработку команд (<b>Задание
6</b>) таким образом, чтобы:
1. команды обрабатывались многопоточно
2. ввод данных управлялся внешним кодом

### <i>1. Многопоточная обработка команд</i>

При старте программы должно быть создано в дополнение к существующему основному потоку
ещё три дополнительных. Дадим им условные имена:
- <b>main</b> – основной поток (в пользовательском приложении);
- <b>log</b> – поток для вывода данных в консоль;
- <b>file1</b> – первый поток для вывода в файл;
- <b>file2</b> – второй поток для вывода в файл;

Основная логика обработки меняется таким образом, что блок команд после своего формирования
должен быть отправлен в консоль (потоком <b>log</b>) и сразу в файл (одним из потоков <b>file1</b> или <b>file2</b>). <br>
При этом отправка блока в файл распределяется между файловыми потоками. <br>
Можно напрямую отправлять, например, чётные команды через поток <b>file1</b>, а нечётные – через
<b>file2</b>. Но лучшим решение станет использование единой очереди команд, которую будут
обрабатывать оба файловых потока одновременно.<br>
Следует обратить внимание на недостаточную точность часов для формирования уникального
имени. Необходимо, сохранив timestamp в имени, добавить дополнительный постфикс, который
будет гарантированно отличаться у файловых потоков.<br>

### <i>2. Управление вводом данных внешним кодом</i>

В рамках этой части работы нужно выполнить код в виде библиотеки с описанным в файле <b>async.h</b>
внешним интерфейсом.<br>
Инициатором обмена будет выступать внешний код. Вместо привычной точки входа в приложение
`main()` будут три внешних функции `connect()`, `receive()` и `disconnect()`.
Порядок вызовов следующий:
- вызывается `connect()` с передачей размера блока команд, сохраняется значение возврата.
Значение никак не интерпретируется вызывающим кодом и служит только в качестве
контекста для функций `receive()` и `disconnect()`;
- вызывается `receive()` c передачей указателя на начало буфера, его размера, а также
контекста. Вызов повторяемый – вызывающий код может использовать его для передачи
нескольких команд подряд;
- вызывается `disconnect()` с передачей контекста. Вызов разрушает контекст полностью. С
точки зрения логики обработки команд этот вызов считается завершением текущего блока
команд;

Необходимо реализовать эти функции так, чтобы сохранить прежнюю функционально проекта. <br><br>
Реализация должна допускать множественные вызовы `connect()`. Вызовы `receive()` с разными
контекстами не должны мешать друг другу. Вызовы могут осуществляться из разных потоков,
однако вызовы с одинаковым контекстом всегда выполняются из одного и того же потока.<br>
Опционально реализовать возможность вызывать все функции из любых потоков.<br>

### <i>Требования к реализации</i>

Результатом работы должна стать библиотека, устанавливаемая по стандартному пути. Библиотека
должна называться <b>libasync.so</b> и находиться в пакете <b>async</b>.
Для проверки работоспособности следует реализовать также исполняемый файл, который
использует библиотеку с демонстрацией всех вызовов. Исполняемый файл также должен быть
добавлен в пакет.


### <i>Проверка</i>
Задание считается выполненным успешно, если после установки пакета, линковки с тестовым
кодом (пример в <b>main.cpp</b>) и запуска с тестовыми данными вывод соответствует описанию <b>Задания
6</b>. Данные подаются порциями в разных контекстах в большом объёме без пауз.
